/*
Mini-SumoBot
Based on "BorderDetect" available on the http://www.pololu.com web site.
This sketch includes the default reflectance sensors (edge sensors), a
forward looking distance sensor, and two side sensors. It is left to the
user to add appropriate programming for a rear sensor. 

Assumptions: 
a) Opponent sensor is connected to A1
b) Side sensors are connected to 2 and 6

This code is provided as an example program for a mini-sumobot. The 
delay() function is not the best way to accomplish this task--but the
software will provide a fairly good competitor. Recognize that by using
the delay() function the robot is not looking at the sensors during 
that period of time.

For changes made to the "BorderDetect" look for the "//NEW" comments on
the right side of the statement.

I've not tested this in competititon, so user beware.

What is missing? There is no attempt to "find" the opponent in this software.
One tactic is to start a medium speed turn looking for the opponent when ever
there is no forward, side, or rear detection of opponent.

Modified from "BorderDetect" by: David Pelowitz, pelowitz@pelowitz.com
Date: 9 November 2013
Modifications: Not yet
*/

#include <ZumoBuzzer.h>
#include <ZumoMotors.h>
#include <Pushbutton.h>
#include <QTRSensors.h>
#include <ZumoReflectanceSensorArray.h>
 
#define LED 13
 
// this might need to be tuned for different lighting conditions, surfaces, etc.
#define QTR_THRESHOLD  1500 // microseconds

//change to use the analog port your sensor is attached to
#define OPPONENT_SENSOR A1    //NEW
#define OPP_THRESHOLD  100    //NEW
#define OPP_THRESHOLD2 300    //NEW
//change to use the digital port your left and right sensors are attached to
#define LEFTSIDE 2            //NEW
#define RIGHTSIDE 6           //NEW 
  
// these might need to be tuned for different motor types
#define REVERSE_SPEED     200 // 0 is stopped, 400 is full speed
#define TURN_SPEED        200
#define FORWARD_SPEED     200
#define FASTFORWARD_SPEED 300 //NEW   
#define SUPERFASTFORWARD_SPEED 400 //NEW
#define REVERSE_DURATION  200 // ms
#define TURN_DURATION     400 // ms
#define QUARTER_TURN_DURATION 300 //NEW
 
ZumoBuzzer buzzer;
ZumoMotors motors;
Pushbutton button(ZUMO_BUTTON); // pushbutton on pin 12
 
#define NUM_SENSORS 6
unsigned int sensor_values[NUM_SENSORS];
int iFrontDistance;      //NEW
int iLeftSide;           //NEW 
int iRightSide;          //NEW
 
ZumoReflectanceSensorArray sensors(QTR_NO_EMITTER_PIN);

void waitForButtonAndCountDown()
{
  digitalWrite(LED, HIGH);
  button.waitForButton();
  digitalWrite(LED, LOW);
   
  // play audible countdown
  for (int i = 0; i < 3; i++)
  {
    delay(1000);
    buzzer.playNote(NOTE_G(3), 200, 15);
  }
  delay(1000);
  buzzer.playNote(NOTE_G(4), 500, 15);  
  delay(1000);
}
 
void setup()
{
  // uncomment if necessary to correct motor directions
  //motors.flipLeftMotor(true);
  //motors.flipRightMotor(true);
   
  pinMode(LED, HIGH);
  pinMode(LEFTSIDE,INPUT);    //NEW
  pinMode(RIGHTSIDE,INPUT);   //NEW
  
  waitForButtonAndCountDown();
}

void loop()
{
  if (button.isPressed())
  {
    // if button is pressed, stop and wait for another press to go again
    motors.setSpeeds(0, 0);
    button.waitForRelease();
    waitForButtonAndCountDown();
  }

  sensors.read(sensor_values);
  iFrontDistance = analogRead(OPPONENT_SENSOR);//NEW
  iLeftSide = digitalRead(LEFTSIDE);  //NEW
  iRightSide = digitalRead(RIGHTSIDE);//NEW
  
  if (iFrontDistance > OPP_THRESHOLD)                        //NEW
  {                                                          //NEW
    motors.setSpeeds(FASTFORWARD_SPEED, FASTFORWARD_SPEED);  //NEW
  }                                                          //NEW
  else if (iFrontDistance > OPP_THRESHOLD2)                  //NEW 
  {                                                          //NEW
    motors.setSpeeds(SUPERFASTFORWARD_SPEED,SUPERFASTFORWARD_SPEED);//NEW
  }                                                          //NEW
  else if (iLeftSide == LOW)                                 //NEW
  {                                                          //NEW
    motors.setSpeeds(TURN_SPEED, -TURN_SPEED);               //NEW
    delay(QUARTER_TURN_DURATION);                            //NEW
    motors.setSpeeds(FORWARD_SPEED, FORWARD_SPEED);          //NEW
  }                                                          //NEW
  else if (iRightSide == LOW)                                //NEW
  {                                                          //NEW
    motors.setSpeeds(-TURN_SPEED, TURN_SPEED);               //NEW
    delay(QUARTER_TURN_DURATION);                            //NEW
    motors.setSpeeds(FORWARD_SPEED, FORWARD_SPEED);          //NEW
  }                                                          //NEW
  else if (sensor_values[0] < QTR_THRESHOLD)                 //else NEW
  {
    // if leftmost sensor detects line, reverse and turn to the right
    motors.setSpeeds(-REVERSE_SPEED, -REVERSE_SPEED);
    delay(200);
    motors.setSpeeds(TURN_SPEED, -TURN_SPEED);
    delay(300);
    motors.setSpeeds(FORWARD_SPEED, FORWARD_SPEED);
  }
  else if (sensor_values[5] < QTR_THRESHOLD)
  {
    // if rightmost sensor detects line, reverse and turn to the left
    motors.setSpeeds(-REVERSE_SPEED, -REVERSE_SPEED);
    delay(200);
    motors.setSpeeds(-TURN_SPEED, TURN_SPEED);
    delay(300);
    motors.setSpeeds(FORWARD_SPEED, FORWARD_SPEED);
  }
  else
  {
    // otherwise, go straight
    motors.setSpeeds(FORWARD_SPEED, FORWARD_SPEED);
  }
}
